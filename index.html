<!-- 
Code based on https://threejs.org/examples/?q=orb#misc_controls_orbit
-->
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - orbit controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #ccc;
				color: #000;
			}

			a {
				color: #f00;
			}
		</style>
	</head>

	<body>

		<script type="module">

			import * as THREE from '/js/threejs/build/three.module.js';
            import { MTLLoader } from '/js/threejs/examples/jsm/loaders/MTLLoader.js';
            import { OBJLoader } from '/js/threejs/examples/jsm/loaders/OBJLoader.js';
			import { OrbitControls } from '/js/threejs/examples/jsm/controls/OrbitControls.js';

			let camera, controls, scene, renderer;

			init();
			//render(); // remove when using next line for animation loop (requestAnimationFrame)
			animate();

			function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcccccc );
				// scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 400, 200, 0 );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.listenToKeyEvents( window ); // optional

				//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;

				controls.screenSpacePanning = false;

				controls.minDistance = 100;
				controls.maxDistance = 500;

				controls.maxPolarAngle = Math.PI / 2;

				// world

				// const geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
				// const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );

				// for ( let i = 0; i < 500; i ++ ) {

				// 	const mesh = new THREE.Mesh( geometry, material );
				// 	mesh.position.x = Math.random() * 1600 - 800;
				// 	mesh.position.y = 0;
				// 	mesh.position.z = Math.random() * 1600 - 800;
				// 	mesh.updateMatrix();
				// 	mesh.matrixAutoUpdate = false;
				// 	scene.add( mesh );

				// }

				// Our own code to load in our models
				
                var ourObj;
                
                // Create a material
				var mtlLoader = new MTLLoader();
				mtlLoader.load('cylinder/cylinder_red.mtl', function (materials) {

					materials.preload();

					// Load the object
					var objLoader = new OBJLoader();
					objLoader.setMaterials(materials);
					objLoader.load('cylinder/cylinder_red.obj', function (object) {
						scene.add(object);
						ourObj = object;
						object.position.z = 0;
						object.rotation.x = 0;

					});
				});

                // Create a material
                var mtlLoader = new MTLLoader();
                mtlLoader.load('polyhedron/polyhedron_green.mtl', function (materials) {

                    materials.preload();

                    // Load the object
                    var objLoader = new OBJLoader();
                    objLoader.setMaterials(materials);
                    objLoader.load('polyhedron/polyhedron_green.obj', function (object) {
                        scene.add(object);
                        ourObj2 = object;
                        object.position.z -= 370;
                        object.rotation.x = 250;
                        
                    });
                    
                });

                // Create a material
                var mtlLoader = new MTLLoader();
                mtlLoader.load('tube/tube_blue.mtl', function (materials) {

                    materials.preload();

                    // Load the object
                    var objLoader = new OBJLoader();
                    objLoader.setMaterials(materials);
                    objLoader.load('tube/tube_blue.obj', function (object) {
                        scene.add(object);
                        ourObj3 = object;
                        object.position.z -= 370;
                        object.rotation.x = 250;

                    });
                });
                
				// lights
				let light, light2, light3, light4;
                light = new THREE.PointLight(0xc4c4c4,1);
                light.position.set(0,300,500);
                scene.add(light);
                light2 = new THREE.PointLight(0xc4c4c4,1);
                light2.position.set(500,100,0);
                scene.add(light2);
                light3 = new THREE.PointLight(0xc4c4c4,1);
                light3.position.set(0,100,-500);
                scene.add(light3);
                light4 = new THREE.PointLight(0xc4c4c4,1);
                light4.position.set(-500,300,500);
                scene.add(light4);

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>